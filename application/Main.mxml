<?xml version="1.0" encoding="utf-8"?>
<!-- 

	This is the source code for De MonsterDebugger. This AIR
	application listens to data that is transferred from Flash,
	FLEX or AIR applications that send debug information using
	the appropriate classes.

	Be aware that any traces made to De MonsterDebugger may 
	be viewed by others. De MonsterDebugger is intended to be 
	used to debug Flash, FLEX or AIR applications in a protective
	environment that they will not be used in the final launch. 
	Please make sure that you do not send any debug material to
	the debugger from a live running application. 
	
	Use at your own risk.
	
	@author		Ferdi Koomen, Joost Harts
	@company	De Monsters
	@link 		http://www.deMonsterDebugger.com
	@version 	2.5 (stable)
	
	
	Special thanks to Arjan van Wijk and Thijs Broerse from MediaMonks.nl
	
	
	Copyright 2009, De Monsters
	
	This program is free software: you can redistribute it and/or modify
	it under the terms of the GNU General Public License as published by
	the Free Software Foundation, either version 3 of the License, or
	(at your option) any later version.
	
	This program is distributed in the hope that it will be useful,
	but WITHOUT ANY WARRANTY; without even the implied warranty of
	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
	GNU General Public License for more details.
	
	You should have received a copy of the GNU General Public License
	along with this program. If not, see <http://www.gnu.org/licenses/>.

-->

<mx:WindowedApplication 
	xmlns:mx="http://www.adobe.com/2006/mxml" 
	xmlns:fc="http://www.adobe.com/2006/fc" 
	layout="absolute"
	showTitleBar="false" 
	showStatusBar="false" 
	usePreloader="false" 
	backgroundColor="#7F7F7F" 
	color="#000000" 
	themeColor="haloSilver" 
	borderThickness="0" 
	menu="{nativeMenu}" 
	creationComplete="creationComplete()" 
	closing="closingApplication()" 
	horizontalScrollPolicy="off" 
	verticalScrollPolicy="off"
	xmlns:components="components.*"
	>
	
		
	<mx:Style source="skin/style.css"/>
	
	<mx:Script>
		<![CDATA[

			import air.update.ApplicationUpdaterUI;
			import air.update.events.UpdateEvent;
			import mx.core.Window;
			import mx.collections.ArrayCollection;
			import mx.collections.XMLListCollection;
			import mx.controls.Alert;
			import mx.events.DataGridEvent;
			import mx.events.DataGridEventReason;
			import mx.events.MenuEvent;
			import mx.events.NumericStepperEvent;
			import mx.events.TreeEvent;
			import mx.events.ResizeEvent;
			import mx.events.FlexNativeMenuEvent;
			import mx.events.ListEvent;
			import mx.rpc.events.FaultEvent;
			import mx.rpc.events.ResultEvent;
			import flash.display.NativeWindowDisplayState;
			import flash.events.AsyncErrorEvent;
			import flash.events.Event;
			import flash.events.ErrorEvent;
			import flash.events.IOErrorEvent;
			import flash.events.ProgressEvent;
			import flash.events.SecurityErrorEvent;
			import flash.events.NativeWindowDisplayStateEvent;
			import flash.events.NativeWindowBoundsEvent;
			import flash.events.StatusEvent;
			import flash.geom.Rectangle;
			import flash.net.LocalConnection;
			import flash.net.navigateToURL;
			import flash.net.URLRequest;
			import flash.net.Socket;
			import flash.utils.ByteArray;
			import com.adobe.utils.StringUtil;
			import deng.fzip.FZip;
			import deng.fzip.FZipFile;
			import deng.fzip.FZipEvent;
			import components.PropertyEditor;
			import components.AboutWindow;
			import components.HelpWindow;
			import components.TraceWindow;
			import components.SnapshotWindow;
			import components.ExportedWindow;
			import components.MethodWindow;
			import components.Monitor;
			
			
			// Bindables
			[Bindable] private var tracesAll:ArrayCollection = new ArrayCollection();
			[Bindable] private var tracesFiltered:ArrayCollection = new ArrayCollection();
			[Bindable] private var properties:ArrayCollection = new ArrayCollection();
			[Bindable] private var functions:ArrayCollection = new ArrayCollection();
			[Bindable] private var appAll:XMLListCollection = new XMLListCollection();
			[Bindable] private var appFiltered:XMLListCollection = new XMLListCollection();
			[Bindable] private var displayAll:XMLListCollection = new XMLListCollection();
		    
			// Icons
			[Bindable] [Embed(source="icons/bullet_blue.png")] public var iconDefault:Class;
			[Bindable] [Embed(source="icons/box.png")] public var iconRoot:Class; 
			[Bindable] [Embed(source="icons/error.png")] public var iconWarning:Class; 
			[Bindable] [Embed(source="icons/bullet_blue.png")] public var iconVariable:Class; 
			[Bindable] [Embed(source="icons/bullet_key.png")] public var iconVariableReadonly:Class; 
			[Bindable] [Embed(source="icons/bullet_key.png")] public var iconVariableWriteonly:Class; 
			[Bindable] [Embed(source="icons/tag.png")] public var iconXMLNode:Class; 
			[Bindable] [Embed(source="icons/tag.png")] public var iconXMLValue:Class; 
			[Bindable] [Embed(source="icons/tag_blue.png")] public var iconXMLAttribute:Class; 
			[Bindable] [Embed(source="icons/lightning.png")] public var iconFunction:Class;
			[Bindable] [Embed(source="icons/bullet_wrench.png")] public var iconEdit:Class;
			[Bindable] [Embed(source="icons/bullet_white.png")] public var iconLock:Class;
			[Bindable] [Embed(source="icons/disk.png")] public var iconSave:Class;
			
			
			// Connections
			private var lineOut:LocalConnection;
			private var lineIn:LocalConnection;
			
			
			// Connection names
			private const LINE_OUT					:String = "_debuggerBlue";
			private const LINE_IN					:String = "_debuggerRed";
			
			
			// Types
			private const TYPE_ARRAY				:String = "Array";
			private const TYPE_BOOLEAN				:String = "Boolean";
			private const TYPE_NUMBER				:String = "Number";
			private const TYPE_OBJECT				:String = "Object";
			private const TYPE_VECTOR				:String = "Vector";
			private const TYPE_STRING				:String = "String";
			private const TYPE_INT					:String = "int";
			private const TYPE_UINT					:String = "uint";
			private const TYPE_XML					:String = "XML";
			private const TYPE_XMLLIST				:String = "XMLList";
			private const TYPE_XMLNODE				:String = "XMLNode";
			private const TYPE_XMLVALUE				:String = "XMLValue";
			private const TYPE_XMLATTRIBUTE			:String = "XMLAttribute";
			private const TYPE_METHOD				:String = "MethodClosure";
			private const TYPE_FUNCTION				:String = "Function";
			private const TYPE_BYTEARRAY			:String = "ByteArray";	
			private const TYPE_WARNING				:String = "Warning";		
			
			
			// Access types
			private const ACCESS_VARIABLE			:String = "variable";
			private const ACCESS_CONSTANT			:String = "constant";
			private const ACCESS_ACCESSOR			:String = "accessor";
			private const ACCESS_METHOD				:String = "method";
			
			
			// Permission types
			private const PERMISSION_READWRITE		:String = "readwrite";
			private const PERMISSION_READONLY		:String = "readonly";
			private const PERMISSION_WRITEONLY		:String = "writeonly";
			
			
			// Commands
			private const COMMAND_HELLO				:String = "HELLO";
			private const COMMAND_HELLO_RESPONSE	:String = "HELLO_RESPONSE";
			private const COMMAND_ROOT				:String = "ROOT";
			private const COMMAND_BASE				:String = "BASE";
			private const COMMAND_TRACE				:String = "TRACE";
			private const COMMAND_INSPECT			:String = "INSPECT";
			private const COMMAND_GET_OBJECT		:String = "GET_OBJECT";
			private const COMMAND_GET_DISPLAYOBJECT	:String = "GET_DISPLAYOBJECT";
			private const COMMAND_GET_PROPERTIES	:String = "GET_PROPERTIES";
			private const COMMAND_GET_FUNCTIONS		:String = "GET_FUNCTIONS";
			private const COMMAND_SET_PROPERTY		:String = "SET_PROPERTY";
			private const COMMAND_CALL_METHOD		:String = "CALL_METHOD";
			private const COMMAND_SHOW_HIGHLIGHT	:String = "SHOW_HIGHLIGHT";
			private const COMMAND_HIDE_HIGHLIGHT	:String = "HIDE_HIGHLIGHT";
			private const COMMAND_CLEAR_TRACES		:String = "CLEAR_TRACES";
			private const COMMAND_MONITOR			:String = "MONITOR";
			private const COMMAND_SNAPSHOT			:String = "SNAPSHOT";
			private const COMMAND_NOTFOUND			:String = "NOTFOUND";
			
			
			// Paths
			private const PATH_UPDATE:String = "http://www.demonsterdebugger.com/updateMonsterDebugger.xml";
			private const PATH_TICKER:String = "http://www.demonsterdebugger.com/tickerMonsterDebugger.xml";
			
			
			// Current version
			private const VERSION:String = "2.5";
			
			
			// The current selected tree item target
			private var selectedTarget:String = "";
			
			
			// Open method windows
			private var windows:Array = new Array();
			
			
			// Auto updater framework
			private var updater:ApplicationUpdaterUI;
			
			
			// Local shared object with the preferences
			private var so:SharedObject;
			
			
			// Temp file for buffering incoming data
			private var bufferPackage:ByteArray = new ByteArray();
			
			
			// Auto update timer
			private var autoRefreshTimer:Timer;
			
			
			//preformance storage vector
			private var fpsStorage:Vector.<Number> = new Vector.<Number>;
			private var memStorage:Vector.<Number> = new Vector.<Number>;
			private var timeStorage:Vector.<Number> = new Vector.<Number>;
			
			
			// Zip file
			private var zip:FZip;
			private var zipIndex:Number;
			private var zipExpandPath:String;
			
			
			// Toggle states and preferences
			private var autoClear:Boolean = false;
			private var autoScroll:Boolean = false;
			private var autoRefresh:Boolean = false;
			private var showApp:Boolean = true;
			private var showTraces:Boolean = true;
			private var showMonitor:Boolean = true;
			private var showTree:Boolean = true;
			private var showDisplaytree:Boolean = false;
			private var uiAppHeight:Number = 0; // percent
			private var uiTracesHeight:Number = 0; // percent
			private var uiInspectorWidth:Number = 0; // percent
			private var uiTreeWidth:Number = 0; // percent
			private var uiDisplaytreeWidth:Number = 0; // percent
			private var dontShowProperties:Boolean = false;
			private var alwaysOnTop:Boolean = false;
			private var minimizeToTray:Boolean = false;
			
			
			// Icon loader
			private var iconLoader:Loader;
			
			
			// Default ticker data
			private var tickerMessage:String = "De MonsterDebugger is made specially for you by Design Studio De Monsters";
			private var tickerURL:String = "http://www.demonsters.com";
			
			// Scroll position
			private var displaytreeVPOS:Number = 0;
			private var displaytreeHPOS:Number = 0;
			private var treeVPOS:Number = 0;
			private var treeHPOS:Number = 0;
			private var propertiesVPOS:Number = 0;
			private var functionsVPOS:Number = 0;
			
			
			/**
			 * The application is done loading
			 */
			private function creationComplete():void
			{
				// Get the preferences
				so = SharedObject.getLocal("settings");
				
				// Check if there is any data saved
				if (so.data.saved == true && so.data.version == VERSION)
				{
					// Bug with minimize and close:
					// If you minimize the debugger and close it
					// The window X and Y values are -32000
					if (so.data.windowX < 0) {
						so.data.windowX = 0;
					}
					if (so.data.windowY < 0) {
						so.data.windowY = 0;
					}
					
					// Load the saved data
					autoClear = so.data.autoClear;
					autoScroll = so.data.autoScroll;
					autoRefresh = so.data.autoRefresh;
					nativeWindow.x = so.data.windowX;
					nativeWindow.y = so.data.windowY;
					nativeWindow.width = so.data.windowWidth;
					nativeWindow.height = so.data.windowHeight;
					showApp = so.data.showApp;
					showTraces = so.data.showTraces;
					showMonitor = so.data.showMonitor;
					showTree = so.data.showTree;
					showDisplaytree = so.data.showDisplaytree;
					uiAppHeight = so.data.uiAppHeight;
					uiTracesHeight = so.data.uiTracesHeight;
					uiInspectorWidth = so.data.uiInspectorWidth;
					uiTreeWidth = so.data.uiTreeWidth;
					uiDisplaytreeWidth = so.data.uiDisplaytreeWidth;
					dontShowProperties = so.data.dontShowProperties;
					tickerMessage = so.data.tickerMessage;
					tickerURL = so.data.tickerURL;
					alwaysOnTop = so.data.alwaysOnTop;
					minimizeToTray = so.data.minimizeToTray;
				}
				else
				{
					// Set the size
					uiAppHeight = appCanvas.percentHeight;
					uiTracesHeight = tracesCanvas.percentHeight;
					uiTreeWidth = treeCanvas.percentWidth;
					uiDisplaytreeWidth = displaytreeCanvas.percentWidth;
					uiInspectorWidth = inspectorCanvas.percentWidth;
				
					// Reset the data and save the default values
					so.data.version = VERSION;
					so.data.autoClear = autoClear;
					so.data.autoScroll = autoScroll;
					so.data.autoRefresh = autoRefresh;
					so.data.showApp = showApp;
					so.data.showTraces = showTraces;
					so.data.showMonitor = showMonitor;
					so.data.showTree = showTree;
					so.data.showDisplaytree = showDisplaytree;
					so.data.uiAppHeight = uiAppHeight;
					so.data.uiTracesHeight = uiTracesHeight;
					so.data.uiInspectorWidth = uiInspectorWidth;
					so.data.uiTreeWidth = uiTreeWidth;
					so.data.uiDisplaytreeWidth = uiDisplaytreeWidth;
					so.data.dontShowProperties = dontShowProperties;
					so.data.windowX = nativeWindow.x;
					so.data.windowY = nativeWindow.y;
					so.data.windowWidth = nativeWindow.width;
					so.data.windowHeight = nativeWindow.height;
					so.data.windowMaximized = false;
					so.data.tickerMessage = tickerMessage;
					so.data.tickerURL = tickerURL;
					so.data.alwaysOnTop = alwaysOnTop;
					so.data.minimizeToTray = minimizeToTray;
					so.data.saved = true;
				}
				
				// Check if the window should be in fullscreen
				// Only PC's support the windowMaximized property
				if (NativeWindow.supportsMenu) {
					if (so.data.windowMaximized == true) {
						nativeWindow.maximize();
					} else {
						nativeWindow.maximize();
						nativeWindow.restore();
					}
				}
				
				// Set the size
				appCanvas.percentHeight = uiAppHeight;
				tracesCanvas.percentHeight = uiTracesHeight;
				treeCanvas.percentWidth = uiTreeWidth;
				displaytreeCanvas.percentWidth = uiDisplaytreeWidth;
				inspectorCanvas.percentWidth = uiInspectorWidth;
				
				// Update the inteface
				updateInterface();
				
				// Add event listeners to the window
				nativeWindow.addEventListener(NativeWindowDisplayStateEvent.DISPLAY_STATE_CHANGE, updateInterface);
				nativeWindow.addEventListener(NativeWindowBoundsEvent.RESIZING, resizeInterface);
				nativeWindow.addEventListener(NativeWindowBoundsEvent.RESIZE, resizeInterface);
				nativeWindow.addEventListener(NativeWindowDisplayStateEvent.DISPLAY_STATE_CHANGING, stateChangeWindow);
				nativeWindow.activate();
				
				// Check if the window should be on top
				// The value should be set with a small delay
				// else this won't work...
				var timer:Timer = new Timer(100);
				timer.start();
				timer.addEventListener(TimerEvent.TIMER, function(event:TimerEvent):void {
					timer.stop();
					if (alwaysOnTop) {
						nativeWindow.orderToFront();
						nativeWindow.alwaysInFront = true;
					}
				});
				
				// Init the updater
				updater = new ApplicationUpdaterUI();
				checkForUpdate();
				
				// Load the ticker
				tickerData.send();
				
				// Setup line out
				lineOut = new LocalConnection();
				lineOut.addEventListener(AsyncErrorEvent.ASYNC_ERROR, asyncErrorHandler);
				lineOut.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);
				lineOut.addEventListener(StatusEvent.STATUS, statusHandler);
				
				// Setup line in
				lineIn = new LocalConnection();
				lineIn.addEventListener(AsyncErrorEvent.ASYNC_ERROR, asyncErrorHandler);
				lineIn.addEventListener(SecurityErrorEvent.SECURITY_ERROR, securityErrorHandler);
				lineIn.addEventListener(StatusEvent.STATUS, statusHandler);
				lineIn.allowDomain("*");
				lineIn.client = this;
				
				// Timer for the auto update
				autoRefreshTimer = new Timer(2000);
				autoRefreshTimer.start();
				autoRefreshTimer.addEventListener(TimerEvent.TIMER, autoRefreshCallback);
				
				try {				
					lineIn.connect(LINE_IN);
				} catch(error:ArgumentError) {
					errorCanvas.visible = true;
				}
				
				// Send the first message
				send({text:COMMAND_HELLO});
			}
			
			
			/**
			 * This function is called from the application
			 * @param data: A compressed package
			 */
			public function onReceivedData(data:Object):void
			{
				// Check if we received the first package
				if (data.nr == 1)
				{
					// Yes, so clear the temp file
					bufferPackage = new ByteArray();
					bufferPackage.bytesAvailable
					bufferPackage.writeBytes(data.bytes, 0, data.bytes.bytesAvailable);
				}
				else 
				{			
					// No, we're already busy with a package
					// Just write the bytes in that package	
					bufferPackage.writeBytes(data.bytes, 0, data.bytes.bytesAvailable);
				}
				
				// Check if this is the last chunk of the package
				// If so, then run the command from the package
				if (data.nr == data.total) {
					excecuteCommand(bufferPackage);
				}
			}
			
			
			/**
			 * The actual send function
			 * @param data: The uncompressed data to send
			 */
			private function send(data:Object):void
			{
				if (enabled)
				{
					// Compress the data
					var item:ByteArray = new ByteArray();
					item.writeObject(data);
					item.compress();
					
					// send the data through the line out
					try {
						lineOut.send(LINE_OUT, "onReceivedData", item);
					} catch (error:Error) {
						// Do nothing
					}
					
					// Clear the item
					item = null;
				}
			}
			
			
			/**
			 * The data is received and ready to display
			 * @param data: A compressed object
			 */			
			private function excecuteCommand(data:ByteArray):void
			{
				if (enabled)
				{
					// Uncompress the item data
					data.uncompress();
					
					// Read the command from the data
					var command:Object = data.readObject();
					
					// Variables
					var i:int = 0;
					var n:int = 0;
					var icon:Class;
					var type:String;
					var permission:String;
					var edit:Boolean;
					var runnable:Boolean;
					var parameters:XMLList;
					var targets:XMLList;
					var target:String = "";
					var message:String = "";
					var memory:String = "";
					var date:Date;
					var hours:String;
					var minutes:String;
					var seconds:String;
					var miliseconds:String;
					var time:String;
					var searchTerms:Array
					var item:Object;
					
					// Do the actions
					switch(command.text)
					{
						
						// Received hi!
						case COMMAND_HELLO:
							if (autoClear) clearTraces();
							versionError = null;
							var clientVersion:Number = Number(command.version);
							var appVersion:Number = Number(VERSION);
							if (clientVersion < appVersion) {
								var versionError:Object = {
									line:		"-", 
									time:		"-", 
									target:		"De MonsterDebugger", 
									color:		0xCC0000,
									message: 	"Please update your client class to version " + appVersion +". Double click here to export the class.", 
									xml: 		null,
									date:		new Date(),
									memory:		""
								};
								tracesAll.addItem(versionError);
								tracesFiltered.addItem(versionError);
							}
		       				selectedTarget = null;
		       				appAll.source = null;
		       				appFiltered.source = null;
		       				displayAll.source = null;
		       				if (propertiesGrid) propertiesGrid.destroyItemEditor();
							if (functionsGrid) functionsGrid.destroyItemEditor();
		       				properties.removeAll();
		       				functions.removeAll();
		       				monitor.reset();
		       				displaytreeVPOS = 0;
		       				displaytreeHPOS = 0;
		       				treeVPOS = 0;
		       				treeHPOS = 0;
		       				propertiesVPOS = 0;
		       				functionsVPOS = 0;
		       				send({text:COMMAND_HELLO_RESPONSE});
							send({text:COMMAND_ROOT, functions:false});
						break;
						
						
						// Received the root of the app
						case COMMAND_ROOT:
		       				selectedTarget = null;
		       				appAll.source = command.xml.children(); 
		       				appFiltered.source = command.xml.children();
		       				tree.openItems = command.xml.children();
		       				filterApplication();
							if (propertiesGrid) propertiesGrid.destroyItemEditor();
							if (functionsGrid) functionsGrid.destroyItemEditor();
		       				properties.removeAll();
		       				functions.removeAll();
		       				displaytreeVPOS = 0;
		       				displaytreeHPOS = 0;
		       				treeVPOS = 0;
		       				treeHPOS = 0;
		       				propertiesVPOS = 0;
		       				functionsVPOS = 0;
						break;
						
						
						// Received the display object's root
						case COMMAND_BASE:
		       				displayAll.source = command.xml.children();
		       				displaytree.openItems = command.xml.children();
						break;
						
						
						// Received a new target for the inspector
						case COMMAND_INSPECT:
		       				selectedTarget = null;
		       				appAll.source = command.xml.children(); 
		       				appFiltered.source = command.xml.children();
		       				tree.openItems = command.xml.children();
		       				filterApplication();
							if (propertiesGrid) propertiesGrid.destroyItemEditor();
							if (functionsGrid) functionsGrid.destroyItemEditor();
		       				properties.removeAll();
		       				functions.removeAll();
		       				displaytreeVPOS = 0;
		       				displaytreeHPOS = 0;
		       				treeVPOS = 0;
		       				treeHPOS = 0;
		       				propertiesVPOS = 0;
		       				functionsVPOS = 0;
						break;
						
						
						//Received object data
						case COMMAND_GET_OBJECT:
						
							// Get all targets in the current xml
							targets = appAll.source..@target;
							
							// Loop through the targets
							for (i = 0; i < targets.length(); i++)
							{	
								// If they match then update the xml
								if (targets[i] == command.xml.node.@target) {
									targets[i].parent().setChildren(command.xml.node.children());						
									break;
								}
							}

							// Filter the tree
							filterApplication();
							
							// Set the scroll
							tree.verticalScrollPosition = treeVPOS;
							tree.horizontalScrollPosition = treeHPOS;
							
						break;
						
						
						// Received object data
						case COMMAND_GET_DISPLAYOBJECT:
						
							// Get all targets in the current xml
							targets = displayAll.source..@target;
							
							// Loop through the targets
							for (i = 0; i < targets.length(); i++)
							{	
								// If they match then update the xml
								if (targets[i] == command.xml.node.@target) {
									targets[i].parent().setChildren(command.xml.node.children());						
									break;
								}
							}
							
							// Set the scroll
							displaytree.verticalScrollPosition = displaytreeVPOS;
							displaytree.horizontalScrollPosition = displaytreeHPOS;
							
						break;
						
						
						// Received properties  data
						case COMMAND_GET_PROPERTIES:
							
							// Save the properties
							var prop:XMLList = command.xml.node.children();
							
							// Clear the array
							properties.removeAll();
							
							// Loop through the properties
							for (i = 0; i < prop.length(); i++)
							{
								// Default values
								icon = iconLock;
								type = prop[i].@type;
								permission = prop[i].@permission;
								edit = false;
								
								// Check if we can edit the variable
								if (type == TYPE_STRING || type == TYPE_BOOLEAN || type == TYPE_NUMBER || type == TYPE_INT || type == TYPE_UINT) {
									if (permission == PERMISSION_READWRITE) {
										icon = iconEdit;
										edit = true;
									}
								}
								
								// Save the property
								properties.addItem({
									icon:			icon,
									edit:			edit,
									label:			prop[i].@label,
									name:			prop[i].@name,
									type:			prop[i].@type,
									value:			prop[i].@value,
									target:			prop[i].@target,
									access:			prop[i].@access,
									permission:		prop[i].@permission
								});
							}
							
							// Set the scroll
							if (propertiesGrid) propertiesGrid.verticalScrollPosition = propertiesVPOS;
						break;
						
						
						// Received functions data
						case COMMAND_GET_FUNCTIONS:
							
							// Save the properties
							var func:XMLList = command.xml.node.children();
							
							// Clear the array
							functions.removeAll();
							
							// Loop through the properties
							for (i = 0; i < func.length(); i++)
							{
								// Default values
								icon = iconFunction;
								runnable = true;
								
								// Loop through the parameters
								parameters = func[i]..parameter;
								for (n = 0; n < parameters.length(); n++)
								{
									// Save the parameter info
									var paramType:String = parameters[n].@type;
									var paramOptional:String = parameters[n].@optional;
									
									// Check if we can supply the parameter type
									if (paramOptional == "false") {
										if (paramType != TYPE_STRING && paramType != TYPE_BOOLEAN && paramType != TYPE_NUMBER && paramType != TYPE_INT && paramType != TYPE_UINT) {
											icon = iconLock;
											runnable = false;
										}
									}
								}
								
								// Save the property
								functions.addItem({
									icon:			icon,
									runnable:		runnable,
									label:			func[i].@label,
									name:			func[i].@name,
									type:			func[i].@type,
									args:			func[i].@args,
									returnType:		func[i].@returnType,
									target:			func[i].@target,
									access:			func[i].@access,
									parameters:		func[i]..parameter
								});
							}
							
							// Set the scroll
							if (functionsGrid) functionsGrid.verticalScrollPosition = functionsVPOS;
						break;
						
						
						// A reply to a function call has been given
						case COMMAND_CALL_METHOD:
							
							// Loop through the method windows
							for (i = 0; i < windows.length; i++) {
								// We're checking a window title, this might be a bit tricky
								if (windows[i] && windows[i].closed == false && windows[i].title == "De MonsterDebugger - Method") {
									windows[i].checkReturnValue(command["id"], command["xml"]);
								}
							}
							
						break;
						
						
						// Received a trace
						case COMMAND_TRACE:
						
							// Format the time
							date 		= command.date;
							hours 		= (date.getHours() < 10) ? "0" + date.getHours().toString() : date.getHours().toString();
							minutes 	= (date.getMinutes() < 10) ? "0" + date.getMinutes().toString() : date.getMinutes().toString();
							seconds 	= (date.getSeconds() < 10) ? "0" + date.getSeconds().toString() : date.getSeconds().toString();
							miliseconds	= date.getMilliseconds().toString();
							time 		= hours + ":" + minutes + ":" + seconds + "." + miliseconds;
							memory      = Math.round(command.memory / 1024) +  " Kb";
							
							// Create the message
							if (command.xml.children()[0].children().length() == 0) {
								message = stripBreaks(htmlUnescape(command.xml.children()[0].@label));
							} else {
								message = stripBreaks(htmlUnescape(command.xml.children()[0].@label)) + " ...";
							}
							
							// Save the item
							item = {
								line:		tracesAll.length + 1, 
								time:		time, 
								target:		command.target, 
								color:		command.color,
								message: 	message, 
								xml: 		command.xml,
								date:		date, 
								memory:		memory
							};
							
							// Add the item to the array
							tracesAll.addItem(item);
							
							// Get the search terms from the input field
							searchTerms = filterTracesSearchTerms();
							
							// Check if a filter term is given
							if (searchTerms.join("") == "")
							{
								// No, so just add the item
								tracesFiltered.addItem(item);
								timeStorage.push(date.time);
							} 
							else
							{
								// Compare strings!
								target = item.target.toLowerCase();
								message = item.message.toLowerCase();
								if (filterTracesCheck(target, searchTerms) || filterTracesCheck(message, searchTerms)) {
									tracesFiltered.addItem(item);
									timeStorage.push(date.time);
								}
							}
		
							// Autoscroll
							if (autoScroll) {
								tracesDatagrid.verticalScrollPosition = tracesDatagrid.maxVerticalScrollPosition + 1;
							}
							
							// Send the dates to the monitor
							monitor.setMarkers(timeStorage);
							
							// Clear the item
							item = null;
							
						break;
						
						
						// Received a snapshot
						case COMMAND_SNAPSHOT:
						
							// Format the time
							date 		= command.date;
							hours 		= (date.getHours() < 10) ? "0" + date.getHours().toString() : date.getHours().toString();
							minutes 	= (date.getMinutes() < 10) ? "0" + date.getMinutes().toString() : date.getMinutes().toString();
							seconds 	= (date.getSeconds() < 10) ? "0" + date.getSeconds().toString() : date.getSeconds().toString();
							miliseconds	= date.getMilliseconds().toString();
							time 		= hours + ":" + minutes + ":" + seconds + "." + miliseconds;
							memory      = Math.round(command.memory / 1024) +  " Kb";
							
							// Read the bitmap
							var bitmapData:BitmapData = new BitmapData(command.width, command.height);
							bitmapData.setPixels(new Rectangle(0, 0, command.width, command.height), command.bytes);
							
							// Save the item
							item = {
								line:		tracesAll.length + 1, 
								time:		time, 
								target:		command.target, 
								color:		command.color, 
								width:		command.width, 
								height:		command.height, 
								bitmapData:	bitmapData, 
								message: 	"Snapshot", 
								xml: 		null,
								date:		date, 
								memory:		memory
							};
							
							// Add the item to the array
							tracesAll.addItem(item);
							
							// Get the search terms from the input field
							searchTerms = filterTracesSearchTerms();
							
							// Check if a filter term is given
							if (searchTerms.join("") == "")
							{
								// No, so just add the item
								tracesFiltered.addItem(item);
								timeStorage.push(date.time);
							} 
							else
							{
								// Compare strings!
								target = item.target.toLowerCase();
								message = item.message.toLowerCase();
								if (filterTracesCheck(target, searchTerms) || filterTracesCheck(message, searchTerms)) {
									tracesFiltered.addItem(item);
									timeStorage.push(date.time);
								}
							}
							
							// Send the dates to the monitor
							monitor.setMarkers(timeStorage);
							
							// Clear the item
							item = null;				
							
						break;
						
						
						// Received new FPS and menory values
						case COMMAND_MONITOR:
							var monitorTIME:Number = command.time;
							var monitorSTART:Number = command.start;
							var monitorFPS:uint = command.fps;
							var monitorMEM:uint = command.memory;
							fpsStorage.push(command.fps);
							memStorage.push(command.memory);
							monitor.addData(monitorTIME, monitorSTART, monitorFPS, monitorMEM);
						break;
						
						
						// Received a clear traces
						case COMMAND_CLEAR_TRACES:
							clearTraces();
						break;
					}
				}
			}
			
			
			/**
			 * Auto update the inspector (every 1 second)
			 */
			private function autoRefreshCallback(event:TimerEvent):void
			{
				if (autoRefresh) {
	   				if (selectedTarget != null)
	   				{
	   					// Destroy the editor
						if (propertiesGrid) propertiesGrid.destroyItemEditor();
						if (functionsGrid) functionsGrid.destroyItemEditor();
						
						// Set scroll
						if (propertiesGrid) propertiesVPOS = propertiesGrid.verticalScrollPosition;
						if (functionsGrid) functionsVPOS = functionsGrid.verticalScrollPosition;
						
						// Send calls
	   					send({text:COMMAND_GET_PROPERTIES, target:selectedTarget});
						send({text:COMMAND_GET_FUNCTIONS, target:selectedTarget});
	   				}
				}
			}
			
			
			/**
			 * Clear the highlight
			 */
			private function clearHighlight():void
			{
				send({text:COMMAND_HIDE_HIGHLIGHT});
			}
			
			
			/**
			 * Clear the traces datagrid
			 */
			private function clearTraces():void
			{
				fpsStorage = new Vector.<Number>;
				memStorage = new Vector.<Number>;
				timeStorage = new Vector.<Number>;
				tracesAll.removeAll();
				tracesFiltered.removeAll();
				tracesDatagrid.horizontalScrollPosition = 0;
				monitor.reset();
			}
			
			
			/**
			 * Update the filter on the taces
			 */
			private function filterTraces():void
			{
				// Clear the array
				tracesFiltered.removeAll()
				timeStorage = new Vector.<Number>();
				
				// Var needed for the loop
				var i:int = 0;
				var target:String = "";
				var message:String = "";
				
				// Get the search terms from the input field
				var searchTerms:Array = filterTracesSearchTerms();
						
				// Check if a filter term is given
				if (searchTerms.join("") == "")
				{
					// No, so just copy all
					for (i = 0; i < tracesAll.length; i++) {
						tracesFiltered.addItem(tracesAll[i]);
						timeStorage.push(tracesAll[i].date.time);
					}
				} 
				else
				{
					// Compare strings
					for (i = 0; i < tracesAll.length; i++)
					{
						// Get the data and lowercase it
						target = tracesAll[i].target.toLowerCase();
						message = tracesAll[i].message.toLowerCase();
	
						// Add if needed
						if (filterTracesCheck(target, searchTerms) || filterTracesCheck(message, searchTerms)) {
							tracesFiltered.addItem(tracesAll[i]);
							timeStorage.push(tracesAll[i].date.time);
						}
					}
				}
				
				// Send the dates to the monitor
				monitor.setMarkers(timeStorage);
			}
			
			
			/**
			 * Get the search terms from the input field
			 */
			private function filterTracesSearchTerms():Array
			{
				var text:String = tracesFilterField.text.toLowerCase();
				var temp:Array = text.split("+");
				var searchTerms:Array = new Array();
				var searchString:String = "";
				for (var i:int = 0; i < temp.length; i++) {
					searchString = StringUtil.trim(temp[i]);
					if (searchString != "") {
						searchTerms.push(searchString);
					}
				}
				return searchTerms;
			}
			
			
			/**
			 * Loop through the search terms and compare strings
			 */
			private function filterTracesCheck(s:String, searchTerms:Array):Boolean
			{
				var add:Boolean = true;
				for (var i:int = 0; i < searchTerms.length; i++) {
					if (s.indexOf(searchTerms[i]) == -1) {
						add = false;
					}
				}
				return add;
			}
			
			
			/**
			 * Refresh the inspector
			 */
			private function refreshInspector():void
			{
				// Set scroll
				if (propertiesGrid) propertiesVPOS = propertiesGrid.verticalScrollPosition;
				if (functionsGrid) functionsVPOS = functionsGrid.verticalScrollPosition;
				
				// We might want to add the following line
				// if (tree.selectedIndex != -1) { Do something }
				if (propertiesGrid) propertiesGrid.destroyItemEditor();
				if (functionsGrid) functionsGrid.destroyItemEditor();
   				properties.removeAll();
   				functions.removeAll();
   				if (selectedTarget != null) {
   					send({text:COMMAND_GET_PROPERTIES, target:selectedTarget});
					send({text:COMMAND_GET_FUNCTIONS, target:selectedTarget});
   				}
			}
			
			
			/**
			 * Reload the application tree
			 */
			private function refreshApplication():void
			{
				// Check if the tree is loaded
				if (tree.openItems)
				{
					// Set scroll
					treeVPOS = tree.verticalScrollPosition;
					treeHPOS = tree.horizontalScrollPosition;
					
					// Get the current open targets
					var open:Array = tree.openItems as Array;
					var targets:Array = new Array();
					for (var i:int = 0; i < open.length; i++) {
						targets.push(String(open[i].@target));
					}
					
					// Sort the targets
					targets = targets.sort();
					
					// Set scroll
					if (propertiesGrid) propertiesVPOS = propertiesGrid.verticalScrollPosition;
					if (functionsGrid) functionsVPOS = functionsGrid.verticalScrollPosition;
					
					// Clear the data
					selectedTarget = null;
					if (propertiesGrid) propertiesGrid.destroyItemEditor();
					if (functionsGrid) functionsGrid.destroyItemEditor();
	   				properties.removeAll();
	   				functions.removeAll();	
	   				
	   				// Update all objects	
					for (var n:int = 0; n < targets.length; n++) {
						send({text:COMMAND_GET_OBJECT, target:targets[n], functions:false});
					}
				}
			}
			
			
			/**
			 * Reload the display tree
			 */
			private function refreshDisplayTree():void
			{
				// Check if the tree is loaded
				if (displaytree.openItems)
				{
					// Set scroll
					displaytreeVPOS = displaytree.verticalScrollPosition;
					displaytreeHPOS = displaytree.horizontalScrollPosition;
					
					// Get the current open targets
					var open:Array = displaytree.openItems as Array;
					var targets:Array = new Array();
					for (var i:int = 0; i < open.length; i++) {
						targets.push(String(open[i].@target));
					}
					
					// Sort the targets
					targets = targets.sort();
					
					// Set scroll
					if (propertiesGrid) propertiesVPOS = propertiesGrid.verticalScrollPosition;
					if (functionsGrid) functionsVPOS = functionsGrid.verticalScrollPosition;
					
					// Clear the data
					selectedTarget = null;
					if (propertiesGrid) propertiesGrid.destroyItemEditor();
					if (functionsGrid) functionsGrid.destroyItemEditor();
	   				properties.removeAll();
	   				functions.removeAll();
	   				
	   				// Update all objects	
					for (var n:int = 0; n < targets.length; n++) {
						send({text:COMMAND_GET_DISPLAYOBJECT, target:targets[n], functions:false});
					}
				}
			}
			
			
			/**
			 * Update the filter on the application tree
			 */
			private function filterApplication():void
			{
				// Check if the app is loaded
				if (appAll.length > 0)
				{
					// Vars needed for the loops
					var data:XMLList = appAll.copy();
					var targets:XMLList = data..@target;
					var children:XMLList;
					var openOld:Array;
					var openNew:Array;
					var i:int = 0;
					var n:int = 0;
					
					// Get the search terms from the input field
					var text:String = appFilterField.text.toLowerCase();
					var temp:Array = text.split("+");
					var searchTerms:Array = new Array();
					var searchString:String = "";
					for (i = 0; i < temp.length; i++) {
						searchString = StringUtil.trim(temp[i]).toLowerCase();
						if (searchString != "") {
							searchTerms.push(searchString);
						}
					}

					// Filter the data
					children = filterChildren(data.node, searchTerms);
					data.setChildren(children);
					
					// Get the filtered targets
					targets = data..@target;
					
					// Get the open items
					openOld = tree.openItems as Array;
					openNew = new Array();
					for (i = 0; i < openOld.length; i++) {
						for (n = 0; n < targets.length(); n++) {
							if (targets[n] == openOld[i].@target) {
								openNew.push(targets[n].parent());
							}
						}
					}
					
					// Set the data
					appFiltered.source = null;
					appFiltered.source = data;
					tree.openItems = openNew;
					
					// Clear the data
					data = null;
				}
			}
			
			
			/**
			 * Recursive filter child nodes
			 * @param children: The nodes to filter
			 * @param searchTerms: The terms to filter on
			 */
			private function filterChildren(children:XMLList, searchTerms:Array):XMLList
			{
				// The return XML
				var xml:XMLList = new XMLList();
				
				// Variables for the loops
				var i:int = 0;
				var n:int = 0;
				var name:String = "";
				var value:String = "";
				var label:String = "";
				var type:String = "";
				var add:Boolean = true;
				var temp:*;
				
				// Loop through the nodes
				for (i = 0; i < children.length(); i++)
				{
					// Get the data
					name = String(children[i].@name).toLowerCase();
					value = String(children[i].@value).toLowerCase();
					label = String(children[i].@label).toLowerCase();
					type = String(children[i].@type).toLowerCase();
					add = true;
					
					// Compare strings
					if (searchTerms.join("") != "") {
						for (n = 0; n < searchTerms.length; n++) {
							if (children[i].children().length() == 0) {
								if (name.indexOf(searchTerms[n]) == -1 && value.indexOf(searchTerms[n]) == -1 && label.indexOf(searchTerms[n]) == -1 && type.indexOf(searchTerms[n]) == -1) {
									add = false;
								}
							}
						}
					}
					
					// Add the node if needed
					if (add) {
						if (children[i].children().length() > 0)
						{
							// The node has children
							temp = children[i];
							temp.setChildren(filterChildren(temp.children(), searchTerms));
							if (temp.children().length() == 0)
							{
								// The node has just one property
								temp.setChildren(XML("<node icon='iconWarning' type='Warning' label='No filter results' name='No filter results'/>"));
							}
							xml += temp;
						}
						else
						{
							// The node is just one value
							if (!dontShowProperties) {
								xml += children[i];
							}
						}
					}
				}
				
				// Return the xml
				return xml;
			}
			
			
			/**
			 * Show a trace in an output window
			 * @param event: The selection event from the data grid
			 */
			private function showTraceWindow(event:Event):void
			{
				// Check if the selected item is still available
				if (event.currentTarget.selectedItem != null)
				{
					// Get the data
					var item:Object = tracesFiltered.getItemAt(event.currentTarget.selectedIndex);
					
					// Check if the user clicked the version alert
					if (item.target == "De MonsterDebugger")
					{
						// Export the client class
						var clientFile:File = File.desktopDirectory;
						clientFile.browseForDirectory("Select a directory");
						clientFile.addEventListener(Event.SELECT, function(event:Event):void {
							zipExpandPath = clientFile.nativePath;
							zipFileExpand("client");
						});
					}
					else if (item.message == "Snapshot" && item.xml == null)
					{
						// Create the window
						var snapshotWindow:SnapshotWindow = new SnapshotWindow();
						snapshotWindow.setData(item);
						snapshotWindow.open();
						centerWindow(snapshotWindow);
						windows.push(snapshotWindow);
						if (alwaysOnTop) {
							snapshotWindow.orderToFront();
							snapshotWindow.alwaysInFront = true;
						}
					}
					else
					{
						// Create the window
						var traceWindow:TraceWindow = new TraceWindow();
						traceWindow.setData(item);
						traceWindow.open();
						centerWindow(traceWindow);
						windows.push(traceWindow);
						if (alwaysOnTop) {
							traceWindow.orderToFront();
							traceWindow.alwaysInFront = true;
						}
					}
				}
			}
			
			
			/**
			 * Show a trace timestamp in the memory monitor
			 * @param event: The roll over event from the data grid
			 */
			private function showTraceTime(event:Event):void
			{
				// Check if the selected item is still available
				if (event.currentTarget.selectedItem != null)
				{
					// Get the data
					var item:Object = tracesFiltered.getItemAt(event.currentTarget.selectedIndex);
					monitor.setMarker(item.date.time);
				}
			}
			
			
			/**
			 * An item in the app tree has been clicked
			 * @param event: Basic event
			 * @param target: live or tree
			 */	
			private function treeClick(event:Event, target:String = "live"):void
			{
				// Remove selection
				if (target.toLowerCase() == "live") {
					displaytree.selectedIndex = -1;
					treeVPOS = tree.verticalScrollPosition;
					treeHPOS = tree.horizontalScrollPosition;
				} else {
					tree.selectedIndex = -1;
					displaytreeVPOS = displaytree.verticalScrollPosition;
					displaytreeHPOS = displaytree.horizontalScrollPosition;
				}
				
				// Check if the target is still there
				if (event.currentTarget.selectedItem != null)
				{
					// Save the type and target
					var objType:String = event.currentTarget.selectedItem.@type;
					var objTarget:String = event.currentTarget.selectedItem.@target;
					
					// Clear the dataproviders
					properties.removeAll();
					functions.removeAll();
					selectedTarget = null;
					propertiesVPOS = 0;
					functionsVPOS = 0;
					
					// Only get the info from objects
					if (objType != TYPE_WARNING && objType != TYPE_STRING && objType != TYPE_BOOLEAN && objType != TYPE_NUMBER && objType != TYPE_INT && objType != TYPE_UINT && objType != TYPE_FUNCTION)
					{
						selectedTarget = objTarget;
						send({text:COMMAND_GET_PROPERTIES, target:objTarget});
						send({text:COMMAND_GET_FUNCTIONS, target:objTarget});
					}
					
					// Hightlight the object on the client side if possible
					send({text:COMMAND_SHOW_HIGHLIGHT, target:objTarget});
				}
			}
			
			
			/**
			 * An item in the tree is open
			 * @param event: Basic event
			 * @param target: live or tree
			 */	
			private function treeOpen(event:TreeEvent, target:String = "live"):void
			{
				// Check if a new target is opened
				if (event.item.@target != null)
				{
					// Send the command
					if (target.toLowerCase() == "live") {
						treeVPOS = tree.verticalScrollPosition;
						treeHPOS = tree.horizontalScrollPosition;
						send({text:COMMAND_GET_OBJECT, target:String(event.item.@target), functions:false});
					} else {
						displaytreeVPOS = displaytree.verticalScrollPosition;
						displaytreeHPOS = displaytree.horizontalScrollPosition;
						send({text:COMMAND_GET_DISPLAYOBJECT, target:String(event.item.@target), functions:false});
					}
				}
			}
			
			
			/**
			 * The inspector tab is clicked
			 */	
			public function inspectorSwitch():void
			{
				if (viewstack.selectedChild == propertiesCanvas)
				{
					applicationMenu.menu[1].menuitem[3].@toggled = true;
					applicationMenu.menu[1].menuitem[4].@toggled = false;
				}
				else if (viewstack.selectedChild == functionsCanvas)
				{
					applicationMenu.menu[1].menuitem[3].@toggled = false;
					applicationMenu.menu[1].menuitem[4].@toggled = true;
				}
			}
			
					
			/**
			 * A numeric stepper has been clicked on the property editor
			 * @param event: Basic event
			 * @param type: Object type
			 */	
			public function propertiesUpdate(event:Event):void
			{
				// Save the vars
				var newValue:Object = event.currentTarget.parent.parent.newValue;
				var value:Object = event.currentTarget.parent.parent.data.value;
				var name:String = event.currentTarget.parent.parent.data.name;
				var type:String = event.currentTarget.parent.parent.data.type;
				var edit:Boolean = event.currentTarget.parent.parent.data.edit;
				var target:String = event.currentTarget.parent.parent.data.target;
				
				// Double check if we can send the edit command
				if (type == TYPE_STRING || type == TYPE_BOOLEAN || type == TYPE_NUMBER || type == TYPE_INT || type == TYPE_UINT) {
					if (edit == true && newValue != value)
					{
						// Send the command
						send({text:COMMAND_SET_PROPERTY, target:target, name:name, value:newValue});
						
						// Set the value
						event.currentTarget.parent.parent.data.value = newValue;
					}
				}
			}
			
			
			/**
			 * A function has been double clicked
			 * @param event: Basic event
			 */	
			private function functionsClick(event:MouseEvent):void
			{
				// Check if the selected item is still there
				if (functionsGrid.selectedItem != null)
				{
					// Get the data
					var item:Object = functionsGrid.selectedItem;
					
					// Check if we can run the function
					if (item.runnable)
					{
						// Create the window
						var methodWindow:MethodWindow = new MethodWindow();
						methodWindow.id = "methodWindow"
						methodWindow.setData(item, send);
						methodWindow.open();
						centerWindow(methodWindow);
						windows.push(methodWindow);
						if (alwaysOnTop) {
							methodWindow.orderToFront();
							methodWindow.alwaysInFront = true;
						}
					}
				}
			}
			
			
			/**
			 * Check for an update
			 */	
			private function checkForUpdate():void
			{
				// The code below is a hack to work around a bug in the framework so that CMD-Q still works on Mac OSX
				// This is a temporary fix until the framework is updated (3.02)
				// See http://www.adobe.com/cfusion/webforums/forum/messageview.cfm?forumid=72&catid=670&threadid=1373568
				NativeApplication.nativeApplication.addEventListener(Event.EXITING, 
					function(event:Event):void {
						var openedWindows:Array = NativeApplication.nativeApplication.openedWindows;
						for (var i:int = 0; i < openedWindows.length; i++) {
							openedWindows[i].close();
						}
				});
				
				// Configuration stuff
				updater.updateURL = PATH_UPDATE; // Server-side XML file describing update
				updater.isCheckForUpdateVisible = false; // We won't ask permission to check for an update
				updater.addEventListener(UpdateEvent.INITIALIZED, onUpdate); // Once initialized, run onUpdate
				updater.addEventListener(ErrorEvent.ERROR, errorHandler); // If something goes wrong, run onError
				updater.initialize(); // Initialize the update framework
			}
			
			
			/**
			 * Check for an update
			 * @event: Update event from the framework
			 */ 
			private function onUpdate(event:UpdateEvent):void
			{
				updater.checkNow(); 
			}
			
			
			/**
			 * Mouse over the advertisement bar
			 */ 
			private function advertisementRollOver():void
			{
				advertisement.setStyle("backgroundColor", "#EEEEEE");
				advertisementLabel.setStyle("color", "#111111");
			}
			
			
			/**
			 * Mouse out the advertisement bar
			 */ 
			private function advertisementRollOut():void
			{
				advertisement.setStyle("backgroundColor", "#666666");
				advertisementLabel.setStyle("color", "#CCCCCC");
			}
			
			
			/**
			 * Load the clicked link
			 * @param event: Basic event
			 */ 
			private function advertisementClick(event:Event):void
			{
				// Check if the advertisement or close button has been clicked
				if (event.target == advertisement) {
					if (tickerURL != "") {
						navigateToURL(new URLRequest(tickerURL));
					}
				}
			}
			
			
			/**
			 * Check if the users minimizes the app
			 */ 
			private function stateChangeWindow(event:NativeWindowDisplayStateEvent):void
			{
				if (event.afterDisplayState == NativeWindowDisplayState.MINIMIZED) 
				{
					if (minimizeToTray)
					{
						// Don't minimize
						event.preventDefault();
						
						// Hide the window
						nativeWindow.visible = false;
						
						// Create a new native menu
						var menu:NativeMenu = new NativeMenu();
						var menuOpen:NativeMenuItem = new NativeMenuItem("Open De MonsterDebugger");
						var menuExit:NativeMenuItem = new NativeMenuItem("Exit");
						menuOpen.addEventListener(Event.SELECT, trayShow, false, 0, true);
						menuExit.addEventListener(Event.SELECT, trayExit, false, 0, true);
						menu.addItem(menuOpen);
						menu.addItem(new NativeMenuItem("", true));
						menu.addItem(menuExit);
			
						// Init the icon loader
						iconLoader = new Loader();
						iconLoader.contentLoaderInfo.addEventListener(Event.COMPLETE, iconLoadComplete, false, 0, true);
						iconLoader.contentLoaderInfo.addEventListener(IOErrorEvent.IO_ERROR, iconLoadError, false, 0, true);
						
						// Windows
						if (NativeApplication.supportsSystemTrayIcon)
						{
							// Create the system tray icon
							var sysTrayIcon:SystemTrayIcon = NativeApplication.nativeApplication.icon as SystemTrayIcon;
							sysTrayIcon.tooltip = "MonsterDebugger";
							sysTrayIcon.menu = menu;
							sysTrayIcon.addEventListener(ScreenMouseEvent.CLICK, trayShow);
							
							// Load the icon
							iconLoader.load(new URLRequest("icon/icon_16.png"));
						}
					}
				}
			}
			
			
			/**
			 * Show the window
			 */
			private function trayShow(event:Event):void
			{
				nativeWindow.visible = true;
				NativeApplication.nativeApplication.icon.bitmaps = [];
			}
			
			
			/**
			 * Close the app
			 */
			private function trayExit(event:Event):void
			{
				NativeApplication.nativeApplication.icon.bitmaps = [];
				closingApplication();
				NativeApplication.nativeApplication.exit();
			}
			
			
			/**
			 * The icon is loaded
			 */
			private function iconLoadComplete(event:Event):void
			{
				// Set the loaded image as icon
				var bitmap:Bitmap = iconLoader.content as Bitmap;
				NativeApplication.nativeApplication.icon.bitmaps = [bitmap.bitmapData];
			}
			
			
			/**
			 * Unable to load the icon
			 */
			private function iconLoadError(event:Event):void
			{
				// Set a default white square as icon
				if (NativeApplication.supportsDockIcon) {
					NativeApplication.nativeApplication.icon.bitmaps = [new BitmapData(128, 128)];
				}
				if (NativeApplication.supportsSystemTrayIcon) {
					NativeApplication.nativeApplication.icon.bitmaps = [new BitmapData(16, 16)];
				}
			}
			
			
			/**
			 * The application is exiting, so save the window preferences
			 */ 
			private function closingApplication():void
			{
				// Save the window preferences
				if (nativeWindow)
				{
					// Save the size
					uiAppHeight = appCanvas.percentHeight;
					uiTracesHeight = tracesCanvas.percentHeight;
					uiTreeWidth = treeCanvas.percentWidth;
					uiDisplaytreeWidth = displaytreeCanvas.percentWidth;
					uiInspectorWidth = inspectorCanvas.percentWidth;
					
					// Dont save the maximized property on a Mac
					// Dont save the width and height if the window is minimized
					// We could save these values on a resize event...
					if (NativeWindow.supportsMenu && nativeWindow.displayState == NativeWindowDisplayState.MAXIMIZED) {
						so.data.windowMaximized = true;
					} else if (nativeWindow.displayState == NativeWindowDisplayState.NORMAL) {
						so.data.windowMaximized = false;
						so.data.windowX = nativeWindow.x;
						so.data.windowY = nativeWindow.y;
						so.data.windowWidth = nativeWindow.width;
						so.data.windowHeight = nativeWindow.height;
					}
					so.data.autoClear = autoClear;
					so.data.autoScroll = autoScroll;
					so.data.autoRefresh = autoRefresh;
					so.data.showApp = showApp;
					so.data.showTraces = showTraces;
					so.data.showMonitor = showMonitor;
					so.data.showTree = showTree;
					so.data.showDisplaytree = showDisplaytree;
					so.data.uiAppHeight = uiAppHeight;
					so.data.uiTracesHeight = uiTracesHeight;
					so.data.uiInspectorWidth = uiInspectorWidth;
					so.data.uiTreeWidth = uiTreeWidth;
					so.data.uiDisplaytreeWidth = uiDisplaytreeWidth;
					so.data.dontShowProperties = dontShowProperties;
					so.data.alwaysOnTop = alwaysOnTop;
					so.data.minimizeToTray = minimizeToTray;
					so.data.saved = true;					
				}
			}
			
			
			/**
			 * Export all trace items in one XML
			 * @param file: File to export
			 */
			private function tracesExport(file:File):void
			{
				// Create the XML string
				var xml:String = '';
				xml += '<?xml version="1.0" encoding="utf-8"?>' + '\n';
				xml += '<items>' + '\n';
				
				// Loop through the items
				for (var i:int = 0; i < tracesAll.length; i++) {
					xml += '<item>' + '\n';
					xml += '<line>' + tracesAll[i].line + '</line>' + '\n';
					xml += '<time>' + tracesAll[i].time + '</time>' + '\n';
					xml += '<target>' + tracesAll[i].target + '</target>' + '\n';
					xml += '<color>' + tracesAll[i].color + '</color>' + '\n';
					xml += '<timestamp>' + tracesAll[i].date.time + '</timestamp>' + '\n';
					xml += '<memory>' + tracesAll[i].memory + '</memory>' + '\n';
					xml += tracesAll[i].xml + '\n';
					xml += '</item>' + '\n';
				}

				// Add the preformance numbers
				// xml += '<performance>' + '\n';
				// xml += '<fps>'+ fpsStorage.join(",") + '</fps>' + '\n';
				// xml += '<memory>' + memStorage.join(",") + '</memory>' + '\n';
				// xml += '</performance>' + '\n';
				
				// Close the XML
				xml += '</items>' + '\n';
				
				// Write XML to a file
				var fileStream:FileStream = new FileStream();
				fileStream.open(file, FileMode.WRITE);
				fileStream.writeUTFBytes(new XML(xml).toString());
				fileStream.close();
				
				// Show an alert here
				var exportedWindow:ExportedWindow = new ExportedWindow();
				exportedWindow.open();
				centerWindow(exportedWindow);
				if (alwaysOnTop) {
					exportedWindow.orderToFront();
					exportedWindow.alwaysInFront = true;
				}
			}
			
			
			/**
			 * Load all traces from a XML
			 * @param file: File to load
			 */
			private function tracesLoad(file:File):void
			{
				// Read the file
				var fileStream:FileStream = new FileStream();
				fileStream.open(file, FileMode.READ);
				var xml:XML = new XML(fileStream.readUTFBytes(fileStream.bytesAvailable));
				fileStream.close();
				
				// Clear the old traces
				tracesAll.removeAll();
				tracesFiltered.removeAll();
				
				// Load the traces from XML
				for (var i:int = 0; i < xml.item.length(); i++)
				{
					// Get the xml
					var xmlRoot:XML = new XML(xml.item[i].root);
					var message:String = "";
					
					// Create the message
					if (xmlRoot.children()[0].children().length() == 0) {
						message = stripBreaks(htmlUnescape(xmlRoot.children()[0].@label));
					} else {
						message = stripBreaks(htmlUnescape(xmlRoot.children()[0].@label)) + " ...";
					}						
					
					var item:Object = {
						line:		xml.item[i].line, 
						time:		xml.item[i].time, 
						target:		xml.item[i].target, 
						color:		xml.item[i].color,
						message: 	message,
						xml: 		xmlRoot,
						date:		new Date(xml.item[i].timestamp),
						memory:		xml.item[i].memory
					};
					
					//Add the item
					tracesAll.addItem(item);
					
					// Clear the item
					item = null;	
				}
				
				// Filter the new traces
				filterTraces();
			}			
			
			
			/**
			 * Start expanding the zip file
			 * @param type: "client" or "example" or "templates"
			 */
			private function zipFileExpand(type:String):void
			{			
				// Set the index
				zipIndex = 0;
				
				// Load zip
				zip = new FZip();
				zip.addEventListener(FZipEvent.FILE_LOADED, zipFileLoaded);
				zip.addEventListener(Event.COMPLETE, zipFileComplete);
				if (type == "client") {
					zip.load(new URLRequest("export/client.zip"));
				}
				if (type == "example") {
					zip.load(new URLRequest("export/example.zip"));
				}
				if (type == "templates") {
					zip.load(new URLRequest("export/templates.zip"));
				}
			}
			
			
			/**
			 * The zip file is open
			 * @param event: Basic event
			 */
			private function zipFileLoaded(event:Event):void
			{
				// Get the zip file
				var zipFile:FZipFile = zip.getFileAt(zipIndex);
				
				// Save the path
				var path:String = zipFile.filename;
				
				// Check if the path is a file or a directory
				if (zipFile.content.length > 0)
				{
					// The path is a file
					var file:File = new File(zipExpandPath + "/" + path);
					
					// Check if we should remove the file first
					if (file.exists) {
						file.deleteFile();
					}
					
					// Create a stream and write the file
					var stream:FileStream = new FileStream();
					stream.open(file, FileMode.WRITE);
					stream.writeBytes(zipFile.content);
					stream.close();
				}
				else
				{
					// The path is a directory
					var dir:File = new File(zipExpandPath + "/" + path);
					dir.createDirectory();
				}
			
				// Up the index
				zipIndex++;
			}
			
			
			/**
			 * The zip file is done reading
			 * @param event: Basic event
			 */
			private function zipFileComplete(event:Event):void
			{
				// Show an alert here
				var exportedWindow:ExportedWindow = new ExportedWindow();
				exportedWindow.open();
				centerWindow(exportedWindow);
				if (alwaysOnTop) {
					exportedWindow.orderToFront();
					exportedWindow.alwaysInFront = true;
				}
			}
			
			
			/**
			 * Set the position of a window to match the app window
			 * @param window: The window to centre
			 */
			private function centerWindow(window:Window):void
			{
				window.nativeWindow.x = nativeWindow.x + ((nativeWindow.width - window.nativeWindow.width) / 2);
				window.nativeWindow.y = nativeWindow.y + ((nativeWindow.height - window.nativeWindow.height) / 2);
			}
			
				
			/**
			 * Resizing the window
			 * @param event: Optional resize event
			 */
			private function resizeInterface(event:NativeWindowBoundsEvent):void
			{
				appFilterField.visible = (treeCanvas.width > 320);
				appFilterLabel.visible = (treeCanvas.width > 360);
			}
			
			
			/**
			 * Return an array containing the key code of the standard
			 * modifier key for either Mac or Windows
			 * @param iten: The menu item to modify
			 */ 
			private function standardOSModifier(item:Object):Array
			{
				var modifiers:Array = new Array();
				if ((Capabilities.os.indexOf("Windows") >= 0)) {
					modifiers.push(Keyboard.CONTROL);
				} else if (Capabilities.os.indexOf("Mac OS") >= 0) {
					modifiers.push(Keyboard.COMMAND);
				}
				return modifiers;
			}
			
			
			/**
			 * Handle menu commands
			 * @parem event: Basic menu event
			 */ 
			private function nativeMenuCommand(event:FlexNativeMenuEvent):void
			{
				var command:String = event.item.@command;
				switch(command)
				{
					case "exit":
					closingApplication();
					nativeApplication.exit();
					break;
					
					case "example":
					var exampleFile:File = File.desktopDirectory;
					exampleFile.browseForDirectory("Select a directory");
					exampleFile.addEventListener(Event.SELECT, function(event:Event):void {
						zipExpandPath = exampleFile.nativePath;
						zipFileExpand("example");
					});
					break;
					
					case "client":
					var clientFile:File = File.desktopDirectory;
					clientFile.browseForDirectory("Select a directory");
					clientFile.addEventListener(Event.SELECT, function(event:Event):void {
						zipExpandPath = clientFile.nativePath;
						zipFileExpand("client");
					});
					break;
					
					case "templates":
					var templatesFile:File = File.desktopDirectory;
					templatesFile.browseForDirectory("Select a directory");
					templatesFile.addEventListener(Event.SELECT, function(event:Event):void {
						zipExpandPath = templatesFile.nativePath;
						zipFileExpand("templates");
					});
					break;
					
					case "help":
					var helpWindow:HelpWindow = new HelpWindow();
					helpWindow.open();
					centerWindow(helpWindow);
					if (alwaysOnTop) {
						helpWindow.orderToFront();
						helpWindow.alwaysInFront = true;
					}
					break;
					
					case "about":
					var aboutWindow:AboutWindow = new AboutWindow();
					aboutWindow.open();
					centerWindow(aboutWindow);
					if (alwaysOnTop) {
						aboutWindow.orderToFront();
						aboutWindow.alwaysInFront = true;
					}
					break;
					
					case "tracesLoad":
					var tracesLoadFile:File = File.desktopDirectory.resolvePath("traces.xml");
					tracesLoadFile.browseForOpen("Open Traces", [new FileFilter("XML Traces File", "*.xml")]);
					tracesLoadFile.addEventListener(Event.SELECT, function(event:Event):void {
						tracesLoad(tracesLoadFile);
					});
					
					break;
					case "tracesExport":
					var tracesExportFile:File = File.desktopDirectory.resolvePath("traces.xml");
					tracesExportFile.browseForSave("Export Traces");
					tracesExportFile.addEventListener(Event.SELECT, function(event:Event):void {
						tracesExport(tracesExportFile);
					});
					break;
					
					case "gotandlearn":
					navigateToURL(new URLRequest("http://www.gotoandlearn.com/play?id=109"));
					break
					
					case "website":
					navigateToURL(new URLRequest("http://www.demonsterdebugger.com"));
					break
					
					case "feedback":
					navigateToURL(new URLRequest("http://www.getsatisfaction.com/demonsters"));
					break
					
					case "as3reference":
					navigateToURL(new URLRequest("http://help.adobe.com/en_US/AS3LCR/Flash_10.0/index.html"));
					break;
					
					case "as3errors":
					navigateToURL(new URLRequest("http://help.adobe.com/en_US/AS3LCR/Flash_10.0/runtimeErrors.html"));
					break;
					
					case "as3iphone":
					navigateToURL(new URLRequest("http://www.mikechambers.com/as3iphone/"));
					break;
					
					case "as3migration":
					navigateToURL(new URLRequest("http://livedocs.adobe.com/flash/9.0/ActionScriptLangRefV3/migration.html"));
					break;
					
					case "as3ria":
					navigateToURL(new URLRequest("http://www.adobe.com/devnet/actionscript/articles/atp_ria_guide/atp_ria_guide.pdf"));
					break;
					
					case "as3player":
					navigateToURL(new URLRequest("http://www.adobe.com/support/flashplayer/downloads.html#fp10"));
					break;
					
					case "focusFilterApp":
					appFilterField.setFocus();
					break;
					
					case "focusFilterTraces":
					tracesFilterField.setFocus();
					break;
					
					case "showProperties":
					applicationMenu.menu[1].menuitem[4].@toggled = false;
					viewstack.selectedChild = propertiesCanvas;
					break;
					
					case "showMethods":
					applicationMenu.menu[1].menuitem[3].@toggled = false;
					applicationMenu.menu[1].menuitem[4].@toggled = true;
					viewstack.selectedChild = functionsCanvas;
					break;
					
					case "dontShowProperties":
					dontShowProperties = !dontShowProperties;
					applicationMenu.menu[1].menuitem[6].@toggled = dontShowProperties;
					filterApplication();
					if (propertiesGrid) propertiesGrid.destroyItemEditor();
					if (functionsGrid) functionsGrid.destroyItemEditor();
	   				properties.removeAll();
	   				functions.removeAll();
	   				selectedTarget = null;
					break;
					
					case "refreshInspector":
					refreshInspector();
					break;
					
					case "refreshApplication":
					refreshApplication();
					break;
					
					case "clearHighlight":
					clearHighlight();
					break;
					
					case "clearTraces":
					clearTraces();
					break;
					
					case "showApp":
					showApp = !showApp;
					if (!showApp && !showDisplaytree) {
						showTraces = true;
					}
					updateInterface();
					break;

					case "showDisplaytree":
					showDisplaytree = !showDisplaytree;
					if (!showApp && !showDisplaytree) {
						showTraces = true;
					}
					updateInterface();
					break;
					
					case "showTraces":
					showTraces = !showTraces;
					updateInterface();
					break;
					
					case "showMonitor":
					showMonitor = !showMonitor;
					updateInterface();
					break;

					case "autoClear":
					autoClear = !autoClear;
					updateInterface();
					break;
					
					case "autoScroll":
					autoScroll = !autoScroll;
					updateInterface();
					break;
					
					case "autoRefresh":
					autoRefresh = !autoRefresh;
					updateInterface();
					break;
					
					case "alwaysOnTop":
					alwaysOnTop =! alwaysOnTop;
					if (alwaysOnTop) {
						nativeWindow.orderToFront();
						nativeWindow.alwaysInFront = true;
					} else {
						nativeWindow.alwaysInFront = false;
					}
					updateInterface();
					break;
					
					case "minimizeToTray":
					minimizeToTray =! minimizeToTray;
					updateInterface();
					break;
				}	
			}
			
					
			/**
			 * Resize the interface panels
			 * @param event: Optional window state change event
			 */
			private function updateInterface(event:NativeWindowDisplayStateEvent = null):void
			{
				// Enable / disable the menus
				applicationMenu.menu[1].menuitem[0].@enabled = true;
				applicationMenu.menu[1].menuitem[1].@enabled = true;
				applicationMenu.menu[1].menuitem[3].@enabled = true;
				applicationMenu.menu[1].menuitem[4].@enabled = true;
				applicationMenu.menu[1].menuitem[6].@enabled = true;
				applicationMenu.menu[1].menuitem[8].@enabled = true;
				applicationMenu.menu[1].menuitem[9].@enabled = true;
				applicationMenu.menu[1].menuitem[10].@enabled = true;
				applicationMenu.menu[1].menuitem[11].@enabled = true;
				applicationMenu.menu[1].menuitem[13].@enabled = true;
				applicationMenu.menu[1].menuitem[14].@enabled = true;
				applicationMenu.menu[1].menuitem[15].@enabled = true;
				
				// Set monitor
				monitorCanvas.visible = showMonitor;
				monitorCanvas.includeInLayout = showMonitor;
								
				// Show live app and display tree
				if (showApp && showDisplaytree)
				{
					// Live canvas
					treeCanvas.visible = true;
					treeCanvas.includeInLayout = true;
					
					// Display tree canvas
					displaytreeCanvas.visible = true;
					displaytreeCanvas.includeInLayout = true;
					
					// Enable / disable menu items
					applicationMenu.menu[1].menuitem[9].@enabled = true;
					applicationMenu.menu[1].menuitem[10].@enabled = true;
				}
				
				// Show live app
				if (showApp && !showDisplaytree)
				{
					// Live canvas
					treeCanvas.visible = true;
					treeCanvas.includeInLayout = true;
					
					// Display tree canvas
					displaytreeCanvas.visible = false;
					displaytreeCanvas.includeInLayout = false;
					
					// Enable / disable menu items
					applicationMenu.menu[1].menuitem[8].@enabled = true;
					applicationMenu.menu[1].menuitem[9].@enabled = false;
				}
				
				// Show display tree
				if (!showApp && showDisplaytree)
				{
					// Live canvas
					treeCanvas.visible = false;
					treeCanvas.includeInLayout = false;
					
					// Display tree canvas
					displaytreeCanvas.visible = true;
					displaytreeCanvas.includeInLayout = true;
					
					// Enable / disable menu items
					applicationMenu.menu[1].menuitem[8].@enabled = false;
					applicationMenu.menu[1].menuitem[9].@enabled = true;
				}
				
				// Show or hide the filter field
				appFilterField.visible = true;
				appFilterLabel.visible = true;
				
				// Show traces and one of the two inspectors
				if (showTraces && (showApp || showDisplaytree))
				{					
					// Application canvas
					appCanvas.visible = true;
					appCanvas.includeInLayout = true;
					
					// Trace canvas
					tracesCanvas.visible = true;
					tracesCanvas.includeInLayout = true;
				}
				
				// Show one of the two inspectors only
				if (!showTraces && (showApp || showDisplaytree))
				{
					// Application canvas
					appCanvas.visible = true;
					appCanvas.includeInLayout = true;
					
					// Trace canvas
					tracesCanvas.visible = false;
					tracesCanvas.includeInLayout = false;

					// Enable / disable the menus
					applicationMenu.menu[1].menuitem[1].@enabled = false;
					applicationMenu.menu[1].menuitem[13].@enabled = false;
				}
				
				// Show traces only
				if (showTraces && (!showApp && !showDisplaytree))
				{
					// Application canvas
					appCanvas.visible = false;
					appCanvas.includeInLayout = false;
					
					// Trace canvas
					tracesCanvas.visible = true;
					tracesCanvas.includeInLayout = true;
					
					// Enable / disable the menus
					applicationMenu.menu[1].menuitem[0].@enabled = false;
					applicationMenu.menu[1].menuitem[3].@enabled = false;
					applicationMenu.menu[1].menuitem[4].@enabled = false;
					applicationMenu.menu[1].menuitem[6].@enabled = false;
					applicationMenu.menu[1].menuitem[8].@enabled = false;
					applicationMenu.menu[1].menuitem[9].@enabled = false;
					applicationMenu.menu[1].menuitem[10].@enabled = false;
				}
				
				// Set the view menu options
				applicationMenu.menu[1].menuitem[6].@toggled = dontShowProperties;
				applicationMenu.menu[1].menuitem[11].@toggled = autoRefresh;
				applicationMenu.menu[1].menuitem[15].@toggled = autoClear;
								
				// Set the window menu options
				applicationMenu.menu[2].menuitem[0].@toggled = showApp;
				applicationMenu.menu[2].menuitem[1].@toggled = showDisplaytree;
				applicationMenu.menu[2].menuitem[2].@toggled = showTraces;
				applicationMenu.menu[2].menuitem[2].@enabled = (showApp || showDisplaytree);
				applicationMenu.menu[2].menuitem[3].@toggled = showMonitor;
				applicationMenu.menu[2].menuitem[5].@toggled = alwaysOnTop;
				applicationMenu.menu[2].menuitem[8].@toggled = autoScroll;
				
				if (NativeApplication.supportsSystemTrayIcon) {
					applicationMenu.menu[2].menuitem[6].@toggled = minimizeToTray;
				} else {
					applicationMenu.menu[2].menuitem[6].@enabled = false;
					applicationMenu.menu[2].menuitem[6].@toggled = false;
				}
			}
			
			
			/**
			 * The ticker data has been received
			 * @param event: Result event from the XML loader
			 */
			private function tickerDataHandler(event:ResultEvent):void
			{
				// Save the data
				var data:XML = event.result as XML;
				tickerMessage = data.message;
				tickerURL = data.url;
				
				// Set the label
				advertisementLabel.text = tickerMessage;
				
				// Save the message
				so.data.tickerMessage = tickerMessage;
				so.data.tickerURL = tickerURL;
			}
			
			
			/**
			 * The ticker data can't be loaded
			 * Probably no internet connection
			 * @param event: Error from the XML loader
			 */
			private function tickerErrorHandler(event:FaultEvent):void
			{
				// Get the saved data
				tickerMessage = so.data.tickerMessage;
				tickerURL = so.data.tickerURL;
				
				// Set the label
				advertisementLabel.text = tickerMessage;
			}
			
			
			/**
			 * Strip the breaks from a string
			 * @param s: The string to strip
			 */
			private function stripBreaks(s:String):String
			{
				s = s.replace("\n", " ");
				s = s.replace("\r", " ");
				s = s.replace("\t", " ");
				return s;
			}
			
			
			/**
			 * Converts HTML characters to regular characters
			 * @param s: The string to convert
			 */
			private function htmlUnescape(s:String):String
			{
				if (s) {
					
					// Remove html elements
					if (s.indexOf("&apos;") != -1) {
						s = s.split("&apos;").join("\'");
					}
					if (s.indexOf("&quot;") != -1) {
						s = s.split("&quot;").join("\"");
					}
					if (s.indexOf("&lt;") != -1) {
						s = s.split("&lt;").join("<");
					}
					if (s.indexOf("&gt;") != -1) {
						s = s.split("&gt;").join(">");
					}
					if (s.indexOf("&amp;") != -1) {
						s = s.split("&amp;").join("&");
					}
					
					var xml:XML = <a/>;
					xml.replace(0, s);
					return String(xml);
					
				} else {
					return "";
				}
			}
			
			
			private function setupDebugPlayer():void
			{
				// Copy the file "mm.cfg"
				// - Macintosh OS X              MacHD/Library/Application Support/macromedia/
				// - Microsoft Windows Vista     C:\Users\user_name\
				// - Microsoft Windows 2000/XP   C:\Documents and Settings\user_name\
				// - Linux                       /home/user_name/
				
				// Create the file "flashlog.txt"
				// - Macintosh OS X              MacHD/Users/user_name/Library/Preferences/Macromedia/Flash Player/Logs:
				// - Microsoft Windows Vista     C:\Users\user_name\AppData\Roaming\Macromedia\Flash Player\Logs\
				// - Windows 2000/XP             C:\Documents and Settings\user_name\Application Data\Macromedia\Flash Player\Logs\
				// - Linux                       /home/user_name/.macromedia/Flash_Player/Logs/
				
				// We can't finish this function due to the fact that Adobe AIR locks the flash log file 
				// This is the bug report URL: http://bugs.adobe.com/jira/browse/SDK-14536
			}
			
			
			/**
			 * Event handlers
			 * These can be used for debugging
			 */
			private function closeHandler(event:Event):void {}
			private function connectHandler(event:Event):void {}
			private function errorHandler(event:ErrorEvent):void {}
			private function ioErrorHandler(event:IOErrorEvent):void {}
			private function socketDataHandler(event:ProgressEvent):void {}
			private function asyncErrorHandler(event:AsyncErrorEvent):void {}
			private function securityErrorHandler(event:SecurityErrorEvent):void {}
			private function statusHandler(event:StatusEvent):void {}
			
		]]>
	</mx:Script>



	<!-- 
	***************************************************************
	* Ticker data loader
	***************************************************************
	-->

	<mx:HTTPService id="tickerData" url="{PATH_TICKER}" resultFormat="e4x" result="tickerDataHandler(event)" fault="tickerErrorHandler(event)"/>



	<!-- 
	***************************************************************
	* Menu items XML
	***************************************************************
	-->
	
	<mx:XML id="applicationMenu" format="e4x">
		<menubar>
			<menu label="File" mnemonic="0">
				<menuitem label="Export Client Class" command="client" mnemonic="7"/>
				<menuitem label="Export Example" command="example" mnemonic="7"/>
				<menuitem label="Export FDT Templates" command="templates" mnemonic="7"/>
				<menuitem label="" type="separator"/>
				<menuitem label="Export Traces" command="tracesExport" mnemonic="7"/>
				<menuitem label="Load Traces" command="tracesLoad" mnemonic="0"/>
				<menuitem label="" type="separator"/>
				<menuitem label="Exit" command="exit" key="q" mnemonic="1"/>
			</menu>
			<menu label="View" mnemonic="0">
				<menuitem label="Focus on Live Application Filter" command="focusFilterApp" key="f" mnemonic="9"/>
				<menuitem label="Focus on Traces Filter" command="focusFilterTraces" key="F" mnemonic="9"/>
				<menuitem label="" type="separator"/>
				<menuitem label="Show Properties" type="check" toggled="true" command="showProperties" key="P" mnemonic="5"/>
				<menuitem label="Show Methods" type="check" toggled="false" command="showMethods" key="M" mnemonic="5"/>
				<menuitem label="" type="separator"/>
				<menuitem label="Don't show single properties" type="check" toggled="false" command="dontShowProperties" mnemonic="0"/>
				<menuitem label="" type="separator"/>
				<menuitem label="Refresh Live Application" command="refreshApplication" key="R" mnemonic="0"/>
				<menuitem label="Refresh Display Tree" command="refreshDisplayTree" mnemonic="10"/>
				<menuitem label="Refresh Inspector" command="refreshInspector" key="r" mnemonic="8"/>
				<menuitem label="Refresh Inspector automatically" type="check" toggled="false" command="autoRefresh" mnemonic="18"/>
				<menuitem label="" type="separator"/>
				<menuitem label="Clear Highlight" command="clearHighlight" key="i" mnemonic="6"/>
				<menuitem label="Clear Traces" command="clearTraces" key="x" mnemonic="0"/>
				<menuitem label="Clear Traces on connect" type="check" toggled="false" command="autoClear" mnemonic="18"/>
			</menu>
			<menu label="Window" mnemonic="0">
				<menuitem label="Show Live Application" type="check" toggled="true" command="showApp" key="1" mnemonic="5"/>
				<menuitem label="Show Display Tree" type="check" toggled="false" command="showDisplaytree" key="2" mnemonic="5"/>
				<menuitem label="Show Traces" type="check" toggled="false" command="showTraces" key="3" mnemonic="5"/>
				<menuitem label="Show Monitor" type="check" toggled="false" command="showMonitor" key="4" mnemonic="5"/>
				<menuitem label="" type="separator"/>
				<menuitem label="Always on top" type="check" toggled="false" command="alwaysOnTop" mnemonic="0"/>
				<menuitem label="Minimize to tray" type="check" toggled="false" command="minimizeToTray" mnemonic="1"/>
				<menuitem label="" type="separator"/>
				<menuitem label="Auto scroll traces" type="check" toggled="false" command="autoScroll" mnemonic="5"/>
			</menu>
			<menu label="Help" mnemonic="0">
				<menuitem label="Help" command="help" mnemonic="0"/>
				<menuitem label="" type="separator"/>
				<menuitem label="ActionScript 3.0 Reference" command="as3reference" mnemonic="17"/>
				<menuitem label="ActionScript 3.0 Runtime Errors" command="as3errors" mnemonic="25"/>
				<menuitem label="ActionScript 3.0 Reference for iPhone" command="as3iphone" mnemonic="31"/>
				<menuitem label="ActionScript 2.0 Migration" command="as3migration" mnemonic="17"/>
				<menuitem label="Adobe Flash RIA Guide (PDF)" command="as3ria" mnemonic="6"/>
				<menuitem label="Adobe Flash Players" command="as3player" mnemonic="18"/>
				<menuitem label="" type="separator"/>
				<menuitem label="Video tutorial (Gotoandlearn.com)" command="gotandlearn" mnemonic="0"/>
				<menuitem label="" type="separator"/>
				<menuitem label="About" command="about" mnemonic="0"/>
				<menuitem label="Product Website" command="website" mnemonic="8"/>
				<menuitem label="Feedback" command="feedback" mnemonic="4"/>
			</menu>
		</menubar>
	</mx:XML>



	<!-- 
	***************************************************************
	* The actual menu
	***************************************************************
	-->
	<mx:FlexNativeMenu id="nativeMenu" dataProvider="{applicationMenu}" labelField="@label" keyEquivalentField="@key" mnemonicIndexField="@mnemonic" keyEquivalentModifiersFunction="standardOSModifier" showRoot="false" itemClick="nativeMenuCommand(event)"/>



	<!-- 
	***************************************************************
	* Interface
	***************************************************************
	-->
	<mx:VBox x="0" y="1" width="100%" height="100%" horizontalGap="2" verticalGap="2" horizontalScrollPolicy="off" verticalScrollPolicy="off">
		<mx:VDividedBox width="100%" height="100%" minHeight="0" horizontalGap="2" verticalGap="2" liveDragging="true" horizontalScrollPolicy="off" verticalScrollPolicy="off">
			<mx:HDividedBox id="appCanvas" width="100%" height="100%" horizontalGap="2" verticalGap="2" liveDragging="true" horizontalScrollPolicy="off" verticalScrollPolicy="off">
				<mx:Canvas id="treeCanvas" width="100%" height="100%" minWidth="100" horizontalScrollPolicy="off" verticalScrollPolicy="off">
					<mx:Panel width="100%" height="100%"/>
					<mx:Label text="LIVE APPLICATION" fontWeight="bold" x="10" y="8" fontSize="11"/>
					<mx:Label id="appFilterLabel" text="Filter" y="8" right="188"/>
					<mx:TextInput id="appFilterField" height="20" change="filterApplication()" y="6" right="20" width="160"/>			
					<mx:Tree id="tree" dataProvider="{appFiltered}" iconField="@icon" labelField="@label" showRoot="false" openDuration="0" itemOpen="treeOpen(event, 'live')" click="treeClick(event, 'live')" focusIn="refreshApplication()" defaultLeafIcon="@Embed(source='icons/bullet_blue.png')" folderOpenIcon="@Embed(source='icons/folder.png')" folderClosedIcon="@Embed(source='icons/folder.png')" left="5" top="32" right="5" bottom="5"/>
				</mx:Canvas>
				<mx:Canvas id="displaytreeCanvas" width="100%" height="100%" minWidth="100" horizontalScrollPolicy="off" verticalScrollPolicy="off" includeInLayout="false">
					<mx:Panel width="100%" height="100%"/>
					<mx:Label text="DISPLAY TREE" fontWeight="bold" x="10" y="8" fontSize="11"/>		
					<mx:Tree id="displaytree" dataProvider="{displayAll}" iconField="@icon" labelField="@label" showRoot="false" openDuration="0" itemOpen="treeOpen(event, 'tree')" click="treeClick(event, 'tree')" defaultLeafIcon="@Embed(source='icons/bullet_blue.png')" folderOpenIcon="@Embed(source='icons/folder.png')" folderClosedIcon="@Embed(source='icons/folder.png')" left="5" top="32" right="5" bottom="5"/>
				</mx:Canvas>
				<mx:Canvas id="inspectorCanvas" width="350" height="100%" minWidth="200" horizontalScrollPolicy="off" verticalScrollPolicy="off">
					<mx:Panel width="100%" height="100%"/>
					<mx:Label text="INSPECTOR" fontWeight="bold" fontSize="11" x="10" y="8"/>
					<mx:Image y="32" source="skin/assets/TabBar-background.png" left="5" right="5" scaleContent="false" height="18"/>
					<mx:TabBar dataProvider="{viewstack}" itemClick="inspectorSwitch()" x="5" y="32" height="18" toolTip=""/>
					<mx:ViewStack id="viewstack" left="5" top="50" right="5" bottom="5">
						<mx:Canvas id="propertiesCanvas" label="PROPERTIES" width="100%" height="100%">
							<mx:DataGrid id="propertiesGrid" variableRowHeight="true" dataProvider="{properties}" editable="true" left="0" top="0" right="0" bottom="0">
								<mx:columns>
									<mx:DataGridColumn headerText="Name" dataField="name" editable="false">
										<mx:itemRenderer>
											<mx:Component>
												<mx:HBox horizontalGap="2" horizontalScrollPolicy="off" verticalScrollPolicy="off" width="100%">
													<mx:Image source="{data['icon']}" width="16" height="16"/>
													<mx:Label text="{data['name']}" width="100%" color="#000000" toolTip="{'Type: ' + data['type']}"/>
												</mx:HBox>
											</mx:Component>
										</mx:itemRenderer>
									</mx:DataGridColumn>
									<mx:DataGridColumn headerText="Value" wordWrap="true" dataField="value" editable="true" itemEditor="components.PropertyEditor" editorDataField="newValue"/>
								</mx:columns>
							</mx:DataGrid>
						</mx:Canvas>
						<mx:Canvas id="functionsCanvas" label="METHODS" width="100%" height="100%">
							<mx:DataGrid id="functionsGrid" dataProvider="{functions}" doubleClickEnabled="true" doubleClick="functionsClick(event)" left="0" top="0" right="0" bottom="0">
								<mx:columns>
									<mx:DataGridColumn headerText="Name" dataField="name">
										<mx:itemRenderer>
											<mx:Component>
												<mx:HBox doubleClickEnabled="true" horizontalGap="2" horizontalScrollPolicy="off" verticalScrollPolicy="off" width="100%">
													<mx:Image source="{data['icon']}" width="16" height="16"/>
													<mx:Label text="{data['name']}" width="100%" color="#000000" toolTip="{'Parameters: ' + data['args']}"/>
												</mx:HBox>
											</mx:Component>	
										</mx:itemRenderer>
									</mx:DataGridColumn>
								</mx:columns>
							</mx:DataGrid>
						</mx:Canvas>
					</mx:ViewStack>
				</mx:Canvas>
			</mx:HDividedBox>
			<mx:Canvas id="tracesCanvas" width="100%" height="250" minHeight="80">
				<mx:Panel width="100%" height="100%"/>
				<mx:Label text="TRACES" fontWeight="bold" x="10" y="8" fontSize="11"/>
				<mx:TextInput id="tracesFilterField" height="20" width="160" change="filterTraces()" y="6" right="102"/>
				<mx:Label text="Filter" y="8" right="270"/>
				<mx:VRule height="100%"/>
				<mx:Button height="22" click="clearTraces()" toolTip="Clear all traces" y="5" label="CLEAR" right="20"/>
				<mx:DataGrid dataProvider="{tracesFiltered}" id="tracesDatagrid" doubleClickEnabled="true" itemClick="showTraceTime(event)" itemDoubleClick="showTraceWindow(event)" left="5" top="32" right="5" bottom="5">
					<mx:columns>
						<mx:DataGridColumn headerText="#" dataField="line" width="30">
							<mx:itemRenderer>
								<mx:Component>
									<mx:HBox doubleClickEnabled="true" horizontalScrollPolicy="off" verticalScrollPolicy="off" width="100%">
										<mx:Label text="{data['line']}" color="{data['color']}" width="100%" paddingLeft="5" paddingRight="5"/>
									</mx:HBox>
								</mx:Component>		
							</mx:itemRenderer>
						</mx:DataGridColumn>
						<mx:DataGridColumn headerText="Time" dataField="time" width="120">
							<mx:itemRenderer>
								<mx:Component>
									<mx:HBox doubleClickEnabled="true" horizontalScrollPolicy="off" verticalScrollPolicy="off" width="100%">
										<mx:Label text="{data['time']}" color="{data['color']}" width="100%" paddingLeft="5" paddingRight="5"/>
									</mx:HBox>
								</mx:Component>		
							</mx:itemRenderer>
						</mx:DataGridColumn>
						<mx:DataGridColumn headerText="Target" dataField="target" width="300">
							<mx:itemRenderer>
								<mx:Component>
									<mx:HBox doubleClickEnabled="true" horizontalScrollPolicy="off" verticalScrollPolicy="off" width="100%">
										<mx:Label text="{data['target']}" color="{data['color']}" width="100%" paddingLeft="5" paddingRight="5"/>
									</mx:HBox>
								</mx:Component>		
							</mx:itemRenderer>
						</mx:DataGridColumn>
						<mx:DataGridColumn headerText="Message" dataField="message">
							<mx:itemRenderer>
								<mx:Component>
									<mx:HBox doubleClickEnabled="true" horizontalScrollPolicy="off" verticalScrollPolicy="off" width="100%">
										<mx:Label text="{data['message']}" color="{data['color']}" width="100%" paddingLeft="5" paddingRight="5"/>
									</mx:HBox>
								</mx:Component>		
							</mx:itemRenderer>
						</mx:DataGridColumn>
						<mx:DataGridColumn headerText="Memory" dataField="target" width="120">
							<mx:itemRenderer>
								<mx:Component>
									<mx:HBox doubleClickEnabled="true" horizontalScrollPolicy="off" verticalScrollPolicy="off" width="100%">
										<mx:Label text="{data['memory']}" color="{data['color']}" textAlign="right" width="100%" paddingLeft="5" paddingRight="5"/>
									</mx:HBox>
								</mx:Component>		
							</mx:itemRenderer>
						</mx:DataGridColumn>
					</mx:columns>
				</mx:DataGrid>
			</mx:Canvas>
		</mx:VDividedBox>
		<mx:Canvas id="monitorCanvas" width="100%" height="120">
			<mx:Panel width="100%" height="100%"/>
			<mx:Label text="MONITOR" fontWeight="bold" x="10" y="8" fontSize="11"/>
			<components:Monitor id="monitor" left="3" top="30" right="3" bottom="3"/>
		</mx:Canvas>
		<mx:Canvas id="advertisement" width="100%" height="26" backgroundAlpha="1" backgroundColor="#666666" buttonMode="true" useHandCursor="true" rollOver="advertisementRollOver()" rollOut="advertisementRollOut()" click="advertisementClick(event)">
			<mx:Label id="advertisementLabel" y="4" mouseEnabled="false" mouseChildren="false" left="10" right="50" color="#CCCCCC" fontWeight="normal"/>
		</mx:Canvas>
	</mx:VBox>
	<mx:Canvas id="errorCanvas" width="100%" height="100%" backgroundAlpha="0.7" backgroundColor="#000000" visible="false">
		<mx:Canvas width="300" height="200" horizontalCenter="0" verticalCenter="0">		
			<mx:Panel width="100%" height="100%"/>
			<mx:Label text="ERROR" fontWeight="bold" x="10" y="8" fontSize="11"/>
			<mx:TextArea left="3" top="30" right="3" bottom="3" paddingBottom="10" paddingLeft="10" paddingRight="10" paddingTop="10" fontSize="11" fontWeight="bold">
				<mx:text>The debugger connection is already in use, please restart the debugger and try again.</mx:text>
			</mx:TextArea>
		</mx:Canvas>
	</mx:Canvas>
</mx:WindowedApplication>
